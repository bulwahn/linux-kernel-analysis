From f59de3d3a121ed88a08c1582fc40e8f1b7ca986a Mon Sep 17 00:00:00 2001
From: Lukas Bulwahn <lukas.bulwahn@gmail.com>
Date: Sat, 27 Apr 2019 12:40:27 +0200
Subject: [PATCH 78/79] fs/dcache: simplify control flow

---
 fs/dcache.c | 32 ++++++++++++--------------------
 1 file changed, 12 insertions(+), 20 deletions(-)

diff --git a/fs/dcache.c b/fs/dcache.c
index aac41adf4743..59ffeaa69122 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -2877,30 +2877,22 @@ struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)
 static int __d_unalias(struct inode *inode,
 		struct dentry *dentry, struct dentry *alias)
 {
-	struct mutex *m1 = NULL;
-	struct rw_semaphore *m2 = NULL;
-	int ret = -ESTALE;
-
 	/* If alias and dentry share a parent, then no extra locks required */
-	if (alias->d_parent == dentry->d_parent)
-		goto out_unalias;
-
+	if (alias->d_parent == dentry->d_parent) {
+		__d_move(alias, dentry, false);
+		return 0;
+	}
 	/* See lock_rename() */
 	if (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))
-		goto out_err;
-	m1 = &dentry->d_sb->s_vfs_rename_mutex;
-	if (!inode_trylock_shared(alias->d_parent->d_inode))
-		goto out_err;
-	m2 = &alias->d_parent->d_inode->i_rwsem;
-out_unalias:
+		return -ESTALE;
+	if (!inode_trylock_shared(alias->d_parent->d_inode)) {
+		mutex_unlock(&dentry->d_sb->s_vfs_rename_mutex);
+		return -ESTALE;
+	}
 	__d_move(alias, dentry, false);
-	ret = 0;
-out_err:
-	if (m2)
-		up_read(m2);
-	if (m1)
-		mutex_unlock(m1);
-	return ret;
+	up_read(&alias->d_parent->d_inode->i_rwsem);
+	mutex_unlock(&dentry->d_sb->s_vfs_rename_mutex);
+	return 0;
 }
 
 /**
-- 
2.17.1

